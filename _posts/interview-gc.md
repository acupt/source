---
title: JAVA GC 简析
date: 2019-07-15 23:00:00
tags:
 - jvm
 - gc
categories: 面试杂谈
---

> 作为一个落魄的JAVA开发，在面试中常被问道：你是什么垃圾？
> 哦不，是你对JAVA的垃圾回收机制有了解吗？

接下来就对GC做一个全方位的总结，希望下次可以自信地回答面试官：我是可以被贵公司回收的那种。

## GC的时机

首先，根据内存区域不同，JVM工作模式不同，GC也有一些差别。

### 新生代（minor GC/young GC）

> PS: 新生代的内存空间可分为3个，Eden区(产生新生命的伊甸园)，from区和to区（GC时倒腾对象用的两个盘子）

当JVM无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以如果程序疯狂造对象，就会频繁触发GC。

### 老年代/永久代（major GC）/整个堆（full GC）

> 当一个对象经历了太多GC而不死，它会突破旧规则的束缚，飞升到老年代/永久代，成为新的存在，但并不代表着它可以不死，没有谁可以不死，尤其是新的地方也缺少资源的时候。而Major GC通常是跟full GC是等价的，收集整个GC堆。

升到永久代的对象大于永久代剩余空间full gc，或者小于时被HandlePromotionFailure参数强制full gc。

### 其它GC时机：

+ 在程序中调用System.gc()函数，建议JVM做GC（注意只是建议，JVM有权无视程序猿的建议）
+ 调参控制进入老年代/永久代的年龄（如果我记得肯定会写出来的，没搜，懒得搜）
+ OOM之前（在放弃治疗抛出异常前总要做最后的努力吧）

## GC的目标 - 不使用的对象

> 当然是不使用的对象，还在使用的对象给回收了谁知道程序会跑成什么样子

那么什么是不使用的对象呢？

### 超出作用域的对象/引用计数为空

> 引用计数法: 有人引用+1，被人抛弃-1。

+ 优点：一旦没有引用即可释放内存，不需要等待特定时机，回收的时机也比较平均。
+ 缺点：维护计数消耗资源（但问题不大），循环引用（大）

### 可达性分析，有gc root无法到达的对象

> 通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，无法到达的对象就是没用的。
> 可以被当做root的对象，如：线程对象、本地变量、全局变量等。

这里又引入了引用的概念，强度从强到弱依次如下：

+ 强引用：最常见的如 Object a = new Object()，即使OOM也不回收
+ 软引用（SoftReference）：内存不够时回收
+ 弱引用（WeakReference）：正常gc，被扫描到就回收
+ 幻想引用（PhantomReference）：不可以获取/复活对象, 在垃圾回收时得到通知

## GC的行为

简单的说就是删除对象，回收空间。根据算法不同，具体的行为也有所不同，快没电了，就不写了（主要也没准备）

举个栗子：

1、停止其他线程，标记对象
2、清理对象
2.1、新生代-复制清理：
	Eden和from的存活对象复制到to，然后from和to交换，存活对象年龄+1，年龄到达阈值进入老年代/永久代
2.2、老年代-标记清理/整理：
	标记清理速度快，但有内存碎片
    标记整理会移动存活对象，排除内存碎片