---
title: 死锁的四大条件与处理策略
date: 2019-07-21 22:40:00
tags:
 - 死锁
categories: 面试杂谈
---

> 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

比如：两个线程A、B各自持有一个无法共享的资源，并且他们都需要获取对方现在持有的资源才能进行下一步，但是他们又必须等对方释放了才能去获取，于是A等待B，B也在等待A。如此这般，死锁就产生了。

## 产生死锁的四个条件

死锁的发生必须具备以下四个必要条件

### 互斥条件（Mutual exclusion）

    资源不能被共享，只能由一个进程使用。

### 请求与保持条件（Hold and wait）

    已经得到资源的进程可以再次申请新的资源。

### 不可剥夺条件（No pre-emption）

    已经分配的资源不能从相应的进程中被强制地剥夺。

### 环路/循环等待条件（Circular wait）

    系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

了解四个必要条件后再来看看开始的例子：

两个线程各自持有一个无法共享(互斥条件)的资源，并且他们都需要获取（请求与保持条件）对方现在持有的资源才能进行下一步，但是他们又必须等对方释放了才能去获取(不可剥夺条件)，于是A等待B，B也在等待A（环路等待条件）。如此这般，死锁就产生了。

## 预防死锁

通过破坏四个必要条件中的一个或多个，使死锁永远无法满足。实现简单，但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。

### 预先资源分配法

一次性申请所有需要的资源，只要有一种资源不满足要求，哪怕其它需要的资源都足够，也不做任何分配。这样一来就没有“保持”资源的状态，只有“请求”资源的状态，破坏了请求与保持条件。

### 有序资源分配法

在申请不同类资源时，必须按指定顺序申请，破坏了环路等待条件。

+ 正例：线程A、B申请资源顺序均为R1->R2；
+ 反例：A申请顺序为R1->R2，B申请顺序为R2->R1。

## 避免死锁

也是预发死锁，但不会事先去破坏死锁的必要条件，只是有人请求资源时，用某种方法防止系统进入不安全的状态（死锁），从而避免发生死锁。

### 银行家算法

基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。

## 检测死锁和解除

不采取措施防止死锁产生，允许系统产生死锁，但是可以通过一些手段检测出死锁，然后将死锁解除。

检测方法：

1. 定时检测
2. 效率低时检测
3. 进程等待时检测

解除死锁方法：

根据具体业务场景，可以撤销或挂起死锁的进程/线程，使资源释放。